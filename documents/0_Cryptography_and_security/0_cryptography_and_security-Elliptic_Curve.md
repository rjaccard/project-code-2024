
## Chapter 4 Elliptic Curve Cryptography

This chapter provides basic facts about elliptic curves over finite fields and how to use them in cryptography.

## 4.1 Galois Fields

It can be proven that all finite fields have a cardinality of form pk where p is a prime number.

This prime number p is called the *characteristic* of the field. Moreover, finite fields of the same cardinality must be isomorphic. Conversely, for any prime number p and any positive integer k, we can construct a finite field, denoted by GF(pk), with a cardinality of pk. For that, we can just construct the quotient of the ring Zp[X] of polynomials with coefficients in Zp by the ideal generated by a monic irreducible polynomial P(X) of degree k. (Such polynomial always exists!)
So, field elements can be seen as polynomials with coefficient in Zp and degree at most k − 1.

Operations are addition and multiplication of polynomials modulo P(X) and modulo p.

In cryptography, we are mostly interested in fields with cardinality p for a large prime p, i.e., the field Zp, and by fields of cardinality 2k for some integer k. The former is called a *prime field*.

The latter is called a *binary field*. Indeed, it consists of polynomials with binary coefficients and degree at most k − 1. Operations are taken modulo a fixed polynomial P(X) and coefficients are reduced modulo 2. Note that the *representation* of binary field implies the selection of this reference P(X). So, binary fields can have different (isomorphic) representations.

In the AES block cipher (to be seen in another chapter), we use the field GF(28) with P(X) =
X8 + X4 + X3 + X + 1. Since elements are polynomials with binary coefficient and degree up to
7, they are represented as bytes. If a = a7X7 + *· · ·* + a1X + a0, it is represented by the bitstring a7 *· · ·* a1a0. Clearly, the addition in the field corresponds to the XOR: the bitwise exclusive OR.

Multiplication by the byte 0x01 is trivial: a × 0x01 = a. We detail now what is the multiplication by the byte 0x02. Since this byte represents the polynomial X, to multiply by X we just shift by one bit to the left. Now, if shifting makes the monomial X8 appear, we can reduce it modulo P(X), which means that we drop X8 and add (i.e., XOR) the polynomial X4 + X3 + X + 1 which is represented by 0x1b. So, when implementing the multiplication by 0x02, we just shift the byte a by one bit to the left and XOR it to 0x1b if there is a carry bit. I.e., if the byte had a most significant bit of 1 before shifting. Finally, to multiply by 0x03, we can just multiply by 0x01 and by 0x02 and add (i.e., XOR) the two results. In AES, we only need to multiply by 0x01, 0x02, and 0x03.

In binary fields, we note that −a = a for all a. We also have (a + b)2 = a2 + b2 for all a and b: the square operation is a linear one! So, raising to the power 2i is also linear. Square roots are unique: to compute the square root of a, we can just take a2k−1. (Indeed, a2k = a in a field of 2k elements.) Finally, there is a useful function called *trace* on GF(2k). We define

$$\operatorname{Tr}(a)=a+a^{2}+a^{2^{2}}+\cdots+a^{2^{k-1}}$$
Due to the linearity of the square, this is a linear function. Due to the fact that a2k = a, we can see that

$$\begin{array}{rcl}\mbox{Tr}(a)^{2}&=&(a+a^{2}+a^{2^{2}}+\cdots+a^{2^{k-1}})^{2}\\ &=&a^{2}+a^{2^{2}}+a^{2^{3}}+\cdots+a^{2^{k-1}}+a^{2^{k}}\\ &=&a^{2}+a^{2^{2}}+a^{2^{3}}+\cdots+a^{2^{k-1}}+a\\ &=&\mbox{Tr}(a)\end{array}$$
So, Tr(a)2 = Tr(a). This implies that Tr(a) is a root of x2 = x, i.e., that x(x − 1) = 0. Hence, Tr(a) *∈ {*0, 1}. Therefore, the trace is a linear function from GF(2k) to Z2. Furthermore, Tr(x2) =
Tr(x).

Here is an example of application of the trace function which will be used later.

Theorem 4.1. In GF(2k), the equation a = x2 + x in x *has solutions if and only if* Tr(a) = 0.

When there are solutions, there are exactly two which can be written x = θ and x = θ +1 for some
θ.

Proof. Since we have an equation of degree 2, we cannot have more than two solutions. Indeed, if
θ is a solution, then a = x2 + x implies 0 = x2 − θ2 + x − θ. So, 0 = (x − θ)(x − θ + 1). We deduce that either x = θ or x = θ + 1. In any case, there are no more than 2 solutions.

Since Tr(x)2 = Tr(x) and since the trace is linear, when there is a solution x, we must have

${\rm Tr}(a)={\rm Tr}(x^{2}+x)={\rm Tr}(x^{2})+{\rm Tr}(x)={\rm Tr}(x)+{\rm Tr}(x)=0$
To show the converse (i.e. that Tr(a) = 0 implies the existence of a solution), we observe that the mapping x 7→ x2 + x in GF(2k) has preimage sets of size limited to two, due to the above observation. It maps to elements of trace 0, i.e. to half of the GF(2k) set. So, there are at most
2k−1 preimage sets, each of them with at most 2 elements. Since this must cover the entire 2k elements, we deduce that exactly all the elements of trace 0 have a non-empty preimage set and that all non-empty preimage sets have cardinality exactly 2. Hence, an element of trace 0 has always 2 preimages.

⊓⊔

## 4.2 Elliptic Curves

Over the field R, an elliptic curve with parameters a and b consists of a special point O called the point at infinity and of the points (*x, y*) which are solutions of the equation y2 = x3 +ax+b. Since
(*x, y*) being a solution to this equation implies that (x, −y) is also a solution to this equation, the curve is symmetric by the x axis. Since the equation is cubic, the chord passing through two points P = (xP *, y*P ) and Q = (xQ, yQ) of the curve normally intersects the curve on a third point. When this is the case, we let R = (xR, yR) be the symmetric of this third point and call it R = P + Q.

(See Fig. 4.1.) There are cases when some of these three points may be equal, or when some of them are the points at infinity. We discuss all cases below.

More precisely, by writing the slope of the chord

$$\lambda=\frac{y_{Q}-y_{P}}{x_{Q}-x_{P}}$$

we intersect $y=\lambda x+\mu$ (for some $\mu$) with $y^{2}=x^{3}+ax+b$. By substituting $y$ we have $x^{3}-(\lambda x+\mu)^{2}+ax+b=0$. We know that $x_{P}$ and $x_{Q}$ are roots of this equation. The sum of the three roots of this equation is the opposite of the $x^{2}$ coefficient, i.e., $\lambda^{2}$. So, the sum of the $x$ coordinate $y_{P}$ points of intersection is $\lambda^{2}$. Hence $x_{R}=\lambda^{2}-x_{P}-x_{Q}$. We can further obtain $y_{P}=(x_{P}-x_{P})-y_{P}$. We can thus compute $P+Q$ analytically.

We $P$ and $Q$ are symmetric of each other, we have $x_{P}=x_{Q}$ and the slope is infinite. In this case, we say $P+Q=Q$, the point at infinity. Accordingly, we say that $Q$ is intersecting the 
vertical chord and the curve at infinity. I.e., O is the third point of intersection. By convention, the symmetric of O is O itself. If Q is the symmetric of P, we write Q = −P since P + Q = O.

Conversely, we can also consider the chord between P and Q = O. By convention, this is the vertical line going through P. So, the third intersection point is −P, and its symmetric is R = P.

We have P + O = P. So, we define O to be the neutral element.

In the P = Q case, we replace the chord by the tangent (which is a line with a double contact point to the curve). But for the curve to have a tangent on any point, there should not be any singular point. I.e., we need the curve to be *non-singular*. To obtain the slope λ, we say that xP
must be a double-root of x3 − (λx + µ)2 + ax + b = 0. I.e., xP must be a root of the derivative 3x2 − 2λ(λx + µ) + a = 0. Since yP = λxP + µ, we just have 3x2
P − 2λyP + a = 0 from which we deduce

$$\lambda=\frac{3x_{P}^{2}+a}{2y_{P}}$$

This is for $y_{P}\neq0$. For $y_{P}=0$, $P$ is self-inverse, so $P+P=\mathcal{O}$ in this case.

To make sure that all points of the curve have a tangent, we must make sure that the differential of $f(x,y)=y^{2}-(x^{3}+ax+b)$ on any point is not zero. This means that either $\frac{\partial f}{\partial x}\neq0$ or $\frac{\partial f}{\partial y}\neq0$. This means that either $(3x^{2}+x)\neq0$ or $3x\neq0$ or $(0$ or some point $(x,y)$ which is solution to $f(x,y)=0$
∂x ̸= 0 or ∂f
∂y ̸= 0.

This means that either −(3x2+a) ̸= 0 or 2y ̸= 0 on any point (*x, y*) which is solution to f(*x, y*) = 0.

So, this condition is equivalent to 3x2 +a ̸= 0 on all x such that x3 +ax+b = 0. This is equivalent to the polynomials x3 + ax + b and 3x2 + a having no common root. A known criterion for this is that the *resultant* of the two polynomials is nonzero. The resultant can be computed as the determinant of the *Sylvester matrix* of the two polynomials, i.e.

$$\mathsf{Res}=\left|\begin{array}{cccc}1&0&a&b&0\\ 0&1&0&a&0\\ 3&0&0&a&0\\ 0&3&0&0&a\\ 0&0&3&0&a\end{array}\right|=4a^{3}+27b^{2}$$

(We can see that if the polynomials have some common root $x$, then the matrix multiplied by the column $(x^{4},x^{3},x^{2},x,1)^{\mathsf{I}}$ vanishes. Conversely, if the determinant vanishes, then there must be a linear combination of the rows which is zero, which expresses as the existence of some $(u_{1},u_{2},u_{3},u_{4},u_{5})$ such that $(x^{3}+ax+b)(u_{1}x+u_{2})+(3x^{2}+a)(u_{3}x^{2}+u_{4}x+u_{5})=0$. By factoring $3x^{2}+a$ we can see that this implies that the gcd between $x^{3}+ax+b$ and $3x^{2}+a$ has degree at 
least 1, so these two polynomials have a root in common, at least in an extension field.) So, the curve (in any extension field) has a tangent to any point if and only if 4a3 + 27b2 ̸= 0.

It is not easy to see that the addition defines an Abelian group structure on the curve, but it does.

The most frequent usage of elliptic curve in cryptography assumes that the discrete logarithm problem is hard. So, it is used as an alternate structure as Z∗
p. Contrarily to Z∗
p which is always cyclic, elliptic curves are not always cyclic. This can be easily seen by looking at the number of elements of order 2 in the group. In a cyclic group, there can only be one element of order 2, at most. In the above elliptic curve, a point P has order 2 if and only if P = −P and P ̸= O. This is equivalent to P = (*x, y*) such that 2y = 0 and x3 + ax + b = y2. Except when the field has a characteristic two, this is equivalent to y = 0 and x3 + ax + b = 0. So, the number of points of order 2 is equal to the number of roots of the polynomial x3 + ax + b. When it has more than one root, the elliptic curve cannot be cyclic.

In the next sections, we study more the elliptic curves over finite fields.

## 4.3 Elliptic Curves Over A Prime Field

This section presents the case of elliptic curves over Zp, for *p >* 3 prime. (Or other fields of characteristic p, actually.) Note that the p = 3 case is special and will not be covered in this document.

Given the field K of characteristic *p >* 3 and two field elements a and b, we define

$$E_{n,b}({\bf K})=\{O\}\cup\{(x,y)\in{\bf K}^{2};y^{2}=x^{3}+ax+b\}$$

The _discriminant_ is $\Delta=-16(4a^{3}+27b^{2})$. The curve is _non-singular_ if an only if $\Delta\neq0$, and we only cover this case below. We define the point addition over $E_{n,b}({\bf K})$ to give it an Abelian group structure.

- for P = (xP *, y*P ), we let −P = (xP , −yP ) and −O = O;

- for P = (xP *, y*P ) and Q = (xQ, yQ), if Q = −P we let P + Q = O;
* for $P=(x_{P},y_{P})$ and $Q=(x_{Q},y_{Q})$, if $Q\neq-P$ we let $$\lambda=\left\{\begin{array}{ll}\frac{y_{Q}-y_{P}}{x_{Q}-x_{P}}&\mbox{if}\ x_{P}\neq x_{Q}\\ \frac{3x_{P}+a}{2y_{P}}&\mbox{if}\ x_{P}=x_{Q}\end{array}\right.$$ $$x_{R}=\lambda^{2}-x_{P}-x_{Q}$$ $$y_{R}=(x_{P}-x_{R})\lambda-y_{P}$$
and P + Q = R, where R = (xR, yR);

- for the addition to O, we let P + O = O + P = P and O + O = O.
Given u ∈ K, we can easily see that the mapping f from Ea,b(K) to Eu4a,u6b(K) defined by f(*x, y*) = (u2*x, u*3y) and f(O) = O is a *group isomorphism*. So, given v ∈ K, the two curves Ea,b(K) and Ev2a,v3b(K) are isomorphic when v is a quadratic residue (indeed, we can write v = u2
for some u in this case). When v is not a quadratic residue, we say that the two curves are twist of each other. We note that in this case, the curves are isomorphic when considered as curves in a field extension of K (namely, in a super-field in which v becomes a quadratic residue), although they are not isomorphic when considered as curves over K.

We define the j*-invariant* j = 1728
4a3
4a3+27b2 . We can prove that two isomorphic curves have the same j-invariant. (We can easily see this on the above example.) The j-invariant is actually a characteristic of classes of isomorphic curves, as the following result shows.

Theorem 4.2. Over a field K, isomorphic curves have the same j-invariant. Conversely, curves with the same j-invariant are either isomorphic or twist of each other.

So, curves are isomorphic in K or one of its extensions if and only if they have the same j-invariant.

Finally, the order of the curve is close to #K. This is due to x3 + ax + b of having two square roots in nearly half of the cases. It is usually written #Ea,b(K) = #K + 1 − t where t is called the *trace of Frobenius*. (So, t is small.) We have a more precise result below. Theorem 4.3 (Hasse Theorem). Over a field K, the trace of Frobenius t of an elliptic curve satisfies |t| ≤ 2√#K.

We can easily show that two twisted curves such as Ea,b(K) and Ev2a,v3b(K) for v ∈ K which is not a square have a cumulated cardinality of 2 + 2#K. So, the trace of Frobenius is opposite.

Indeed, there are the two neutral elements. Then, for each x, the number of (x, y) ∈ Ea,b(K) plus the number of (vx, y′) ∈ Ev2a,v3b(K) is always equal to 2: if x3 + ax + b = 0, then both are equal to 1. Otherwise one of the two is equal to 2 and the other is equal to 0. Indeed, x3 + ax + b is a nonzero square if and only if (vx)3 + (v2a)(vx) + (v3b) is a nonzero non-square. Since K is a finite field with characteristic different from 2, each nonzero square has exactly two square roots.

## 4.4 Elliptic Curve Over A Binary Field

Before looking in more details at elliptic curves over binary field, we should warn that recent cryptanalytic results from Joux and Vitse [48] raise concerns about the hardness of the discrete logarithm over these curves. So, many are insecure to use. However, on GF(2k) with k prime to avoid subfields, the security is still open.

Over a field K of characteristic 2, except for the special case of *supersingular curves* which will be treated below, *ordinary* curves are defined by two field elements denoted by a2 and a6. We define Ea2,a6(K) = {O} ∪ {(x, y) ∈ K2; y2 + xy = x3 + a2x2 + a6}
The *discriminant* is ∆ = a6. The curve is *non-singular* if and only if ∆ ̸= 0, and we only cover this case below. We define a point addition over Ea2,a6(K) to give it an Abelian group structure:

- for P = (xP *, y*P ), we let −P = (xP *, x*P + yP ) and −O = O; - for P = (xP *, y*P ) and Q = (xQ, yQ), if Q = −P we let P + Q = O;
* for $P=(x_{P},y_{P})$ and $Q=(x_{Q},y_{Q})$, if $Q\neq-P$ we let $$\lambda=\left\{\begin{array}{ll}\frac{y_{Q}+y_{P}}{x_{Q}+x_{P}}&\mbox{if$x_{P}\neq x_{Q}$}\\ \frac{x_{P}^{2}+y_{P}}{x_{P}}&\mbox{if$x_{P}=x_{Q}$}\end{array}\right.$$ $$x_{R}=\lambda^{2}+\lambda+a_{2}+x_{P}+x_{Q}$$ $$y_{R}=(x_{P}+x_{R})\lambda+y_{P}+x_{R}$$
and P + Q = R where R = (xR, yR);

- for the addition to O, we let P + O = O + P = P and O + O = O.
Given u ∈ K, we can easily see that the mapping f from Ea2,a6(K) to Ea2+u2+u,a6(K) defined by f(*x, y*) = (*x, ux* + y) and f(O) = O is a *group isomorphism*. So, given v ∈ K, the two curves Ea2,a6(K) and Ea2+v,a6(K) are isomorphic when Tr(v) = 0 (indeed, we can write v = u2 + u for some u in this case). When Tr(v) = 1, they are only isomorphic as curves in a field extension of K (namely, an extension in which the trace of v vanishes), but not as curves over K. In this case, we say that the two curves are *twist* of each other.

We define the j*-invariant* j = 1/∆.

Like for the prime field case, we can prove that two isomorphic curves have the same j-invariant (this can be seen on the above example). Conversely, two curves with same j-invariant are again isomorphic (as curves) in some extension field. Over the field K, they are either isomorphic or twist of each other.

Finally, the order of the curve is close to #K. This is due to y2 +xy = x3 +a2x2 +a6 of having two solutions y for nearly half of the x. It is usually written #Ea2,a6(K) = #K + 1 − t where t is called the *trace of Frobenius*. (So, t is small.) More precisely, we know that |t| ≤ 2√#K. This is the Hasse Theorem. Supersingular curves.

There exists a special type of curves over binary fields which are called supersingular curves. (This notion should not be confused with the notion of singular curves.) They could be used to construct pairings as we will study later in this chapter.

For supersingular curves, three field elements denoted by a3, a4, and a6 define

$E_{a_{3},a_{4},a_{6}}(\mathbf{K})=\{\mathcal{O}\}\cup\{(x,y)\in\mathbf{K}^{2};y^{2}+a_{3}y=x^{3}+a_{4}x+a_{6}\}$
The *discriminant* is ∆ = a4
3. The curve is *non-singular* if an only if ∆ ̸= 0, and we only cover this case below. We define a point addition over Ea3,a4,a6(K) to give it an Abelian group structure:

- for P = (xP *, y*P ), we let −P = (xP *, y*P + a3) and −O = O; - for P = (xP *, y*P ) and Q = (xQ, yQ), if Q = −P we let P + Q = O;
* for $P=(x_{P},y_{P})$ and $Q=(x_{Q},y_{Q})$, if $Q\neq-P$ we let $$\lambda=\left\{\begin{array}{ll}\frac{y_{Q}+y_{P}}{x_{Q}+x_{P}}&\mbox{if$x_{P}\neq x_{Q}$}\\ \frac{x_{P}^{2}+a_{4}}{a_{3}}&\mbox{if$x_{P}=x_{Q}$}\end{array}\right.$$ $$x_{R}=\lambda^{2}+\lambda+x_{P}+x_{Q}$$ $$y_{R}=(x_{P}+x_{R})\lambda+y_{P}+a_{3}$$
and P + Q = R where R = (xR, yR);

- for the addition to O, we let P + O = O + P = P and O + O = O.
The j*-invariant* is j = 0, and all these curves are isomorphic.

## 4.5 Elliptic Curve Factoring

One simple factoring method (which is not so good) is Pollard's so-called p−1 algorithm. It works as follows:
Input: n s.t. the largest prime factor of p − 1 is at most B
Output: a nontrivial factor of n Complexity: O(B) arithmetic operations

1: pick x at random in {2, . . . , n − 1} 2: if gcd(*x, n*) ̸= 1 then
3:
output this gcd and stop
4: end if
5: i ← 1 6: **while** gcd(x − 1, n) = 1 do
7:
x ← xi mod n
8:
i ← i + 1
9: end while
10: if x = 1 then
11:
fail
12: else
13:
output gcd(x − 1, n) and stop
14: end if
When n = pq, we assume that the largest prime factor B of p−1 is smaller than the largest prime factor of q − 1. This way, xB! mod p should become 1 with good chances while xB! mod *q >* 1.

Hence, gcd((xB! − 1) mod *n, n*) = p.

The above algorithm iteratively compute xi! mod n and checks if gcd((xi! − 1) mod *n, n*) ̸= 1. This works pretty well when one factor p of n is such that p − 1 is smooth. However, we have troubles when

$$\operatorname*{max}_{r|p-1\mathrm{~prime}}r=\operatorname*{max}_{r|q-1\mathrm{~prime}}r$$
as factorial numbers are likely to be multiples of p−1 and q −1 simultaneously, which would make the p − 1 method fails almost all the time.

We can adapt the above algorithm by replacing the Z∗
p group by an elliptic curve over Zp. The magic is that we can define such curve without knowing p and do nearly any computations over it. We select the elliptic curve randomly and use the probability that such elliptic curve will have a smooth degree. We obtain this way the *Elliptic Curve Method (ECM)*. It works with complexity

$$\mathcal{O}\left(e^{\sqrt{(1+o(1))\log p\log\log p}}\right)$$

where $p$ is the smallest prime factor of $n$. It is the best method to find $p$ when it is small. The algorithm is given below:

**Input:**$n$

**Output:** a nontrivial factor of $n$

**Complexity:**$\mathcal{O}(B)$ arithmetic operations where

$$B\approx\min_{p\text{prime factor of}n}E_{N\in[p-2\sqrt{p},p+2\sqrt{p}]}\left(\max_{q\text{prime factor of}N}q\right)$$
1: pick a and X = (*x, y*) at random in Zn
2: let b such that y2 ≡ x3 + ax + b (mod n)

3: i ← 1
4: repeat
5:
        i ← i + 1

6:
        X ← i · X over the curve (modulo n)

7: until division error modulo n
8: if divisor multiple of n then fail

 9: output gcd(divisor, n)
Essentially, we take a random point X = (x, y) then a random elliptic curve going through this
point. This means we select a at random and fix b such that y2 = x3 + ax + b modulo n (as
this would be true modulo p as well). Then we compute iteratively i!.X. We use the standard
double-and-add algorithm with point addition. To compute point addition, we do the operations
modulo n (as they would be true modulo p as well). We just have a problem to check equalities
modulo p. But we only need it to rule out the P + (−P) computation which gives the point at
infinity. For this, we omit the verification and proceed with the standard addition rule. If we
ever try to add P and −P, we should have a division by zero modulo p. This would translate
into a division by a multiple of p modulo n. This would be non-invertible. This typically happens
precisely when i!.X becomes the point at infinity. Then, the multiple of p leaks p by computing
a gcd. It is a case where an exception in the computation gives the precise result we were looking
for!

## 4.6 Using Elliptic Curves

Elliptic curves are often used in cryptography.

In most cases, we use elliptic curves in which the discrete logarithm problem is hard. We list below a few facts about the discrete logarithm problem.

- The discrete logarithm is very easy to compute in *anomalous* elliptic curves over Zp (these
are curves of order p).
- Binary curves may be exposed to recent attacks [48]. - There are some other families of elliptic curves in which the discrete logarithm is easy to
compute.
- In a cyclic group of order n, the Pollard Rho algorithm [64] solves the discrete logarithm
problem in complexity O(√n).
- We can consider tradeoffs. For instance, Bernstein and Lange [17] propose to run a precomputation of complexity O(n
2
3 ) for a curve then compute any discrete logarithm in the
curve with complexity O(n
1
3 ). As people tend to use the very same curves, this may be a
devastating attack.
The choice of a curve must be specified in the *domain parameters*. Typically, this includes

- the choice for a finite field K, so, either some large prime p (for K = Zp), or some q = 2k
(for GF(2k)) together with the selection of an irreducible binary polynomial P(X) of degree
k;
- the field elements defining the curve E over K;
- a point G ∈ E and its order n in the group;
- sometimes, the *cofactor* h of the group, i.e. h = #E
n ;
- sometimes, as well, the seed which was used to generate the above parameters.
In the last option, specifying the seed can be used to convince that the curve was not maliciously generated.

As we can see, we must manipulate modulo p integers, polynomials, field elements, elliptic curve points, in addition to bitstrings and bytes. To convert from one type to the other, it is important to have standards. We refer to http://www.secg.org/download/aid-385/sec1_final.pdf for this. Points are represented as byte strings. The first byte is special. If it is 0x00, the string has only one byte and this represents the point at infinity O. If it is 0x04, what follows is the encoding of x followed by the encoding of y. If the first byte is either 0x02 or 0x03, what follows is only the encoding of x. This is the *point compression* trick.

Indeed, for *prime field curves*, we know that y is a solution of y2 = x3 + ax + b There are two solutions which are opposite of each other modulo p. So, they do not have the same parity. The point we refer to is the one in which the parity of y is the same as the parity of this special byte.

For *ordinary curves over binary fields*, we know that y x is a solution of

$$\left(\frac{y}{x}\right)^{2}+\frac{y}{x}=x+a_{2}+\frac{a_{6}}{x^{2}}$$

The two solutions have a sum equal to 1, so have different traces. The point we refer to is the one in which the trace of $\frac{y}{x}$ is the parity of this special byte.

x is the parity of this special byte.

There are several standards for elliptic curves: FIPS 186-2 by NIST, SEC2 by the SECG
consortium, X9.62 by ANSI, and IEEE P1363. They propose many curves in common, but under different names. The NIST standard includes pseudorandom curves over Zp such as P192 or P256, and ordinary curves over binary fields. This includes pseudorandom curves such as B163, and a special type of curve called *Koblitz curves*, or *anomalous binary curves*. The SECG standard propose the same type of curve and also another special type of curve over prime fields called generalized Koblitz curves. The curve P192 exists under the name secp192r1. The curve P256 exists under the name secp256r1. The curve B163 exists under the name sect163r2. For instance, the curve P256 is the one used in the Swiss biometric passports1.

Here is the curve secp192r1 = P192:

$\mathsf{secp192r1}=\{\mathcal{O}\}\cup\{(x,y)\in\mathbf{Z}_p;y^2=x^3+ax+b\}$.

p
=
6277101735386680763835789423207666416083908700390324961279
a
=
p − 3
b
=
2455155546008943817740293915197451784769108058161191238065
n
=
6277101735386680763835789423176059013767194773182842284081
G
=
03 188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012
=
03 : 602046282375688656758213480587526111916698976636884684818
seed
=
3045ae6f c8422f64 ed579528 d38120ea e12196d5
note that p = 2192 − 264 − 1, 2192 − 295 *< n <* 2192, and n is prime.

Here is the curve sect163r2 = B163:

$$\mbox{set163}r2=\{{\cal O}\}\cup\{(x,y)\in\mbox{GF}(q);y^{2}+xy=x^{3}+a_{2}x^{2}+a_{6}\}$$

$$q=2^{163}$$ $$P(x)=x^{163}+x^{7}+x^{6}+x^{3}+1$$
a2
=
1
a6
=
02 0a601907 b8c953ca 1481eb10 512f7874 4a3205fd n
=
5846006549323611672814742442876390689256843201587
G
=
03 03 f0eba162 86a2d57e a0991168 d4994637 e8343e36
seed
=
85e25bfe 5c86226c db12016f 7553f9d0 e693a268
note that 2162 *< n <* 2162 + 282 and n is prime.

X25519 is another elliptic curve which has become very popular, specially after a scandal that the NSA influenced standardization to adopt a curve in which they knew a trapdoor, because it was not proposed by any company or government agency and because it had very efficient implementations. The curve Curve25519 was proposed in 2005 by Bernstein [18]. Since then, it was adopted in SSH, Tor, Signal (the secure messaging protocol used in WhatsApp, discussed in Section A.4), Bitcoin (discussed in Section A.2), etc. We have

Curve25519 = $\{\mathcal{O}\}\cup\{(x,y)\in\mathbf{Z}_{p};y^{2}=x^{3}+486\;662x^{2}+x\}$
(note that the equation has a different form than the one we used before) with p = 2255 − 19
(which is prime). A proposed base point G has the x-coordinate xG = 9. It has order

$ 2^{252}+2774231777372353535851937790883648493$. 
(which is also prime). In addition to this, a function X25519 is used for the Elliptic Curve Diffie-
Hellman protocol (ECDH).

## 4.7 Elliptic Curve Cryptography

The ECDH key exchange protocol is the variant of the Diffie-Hellman protocol working over an elliptic curve as a group.

It is specified in the SEC1 standard on http://www.secg.org/
1See Section A.7.

collateral/sec1.pdf, and also in IEEE P1363. It is used in Bluetooth 2.12 and in the European biometric passports (in the Extended Access Control protocol, see Section A.7). We have two participants U and V using the same subgroup of order n generated by some point G over an elliptic curve. (Let assume that the group has order hn and that n is prime.) They both select their secret key dU, dV ∈ Z∗
n, respectively.

They compute their public keys QU = dU.G and QV = dV .G, which are points, and exchange them. Then, they both check that the received public key is actually a point of the curve which is generated by G (see below), different from the point at infinity, and that its order is a factor of n. They both compute a point P, either by P = dU.QV or by P = dV .QU. They take the first coordinate xP of P and convert it into a byte string Z. Finally, they compute K = KDF(Z) by using a *Key Derivation Function* KDF. (This notion will be covered in another chapter.)
In the security of ECDH, it is crucial to check that the received keys are indeed generated by G. Checking that they lie in the elliptic curve is quite simple: we just have to check that their coordinate satisfy the equation defining the elliptic curve. But to show that both are generated by G, we need that n is prime, that h is coprime with n, and the following result.

Lemma 4.4. Let E be a group with neutral element O and G ∈ E. We assume that #E = nh, that G has order n, that n is prime, and that h is coprime with n. For all Q ∈ E, we have that Q
is generated by G if and only if nQ = O.

Proof. Clearly, if Q is generated by G, we have Q = xG for some integer x so nQ = *xnG* = xO =
O.

We now want to prove that is nQ = O, then Q is generated by G. We assume nQ = O. For this, let f be the function from the group Z2
n to E defined by f(*a, b*) = aG + bQ. Clearly, f is a group homomorphism. The image set of f is a subgroup of G so its order must divide #E. If f is injective, the image set of f is isomorphic to Z2
n so has order n2. We know that n2 does not divide #E = hn, so f is not injective. Hence, there exists (*a, b*) ∈ Z2
n such that (*a, b*) ̸= (0, 0) and aG + bQ = O. We cannot have b = 0 because G has order n. As n is prime, b is invertible modulo n, and we have Q = (ab−1 mod n).G. So, Q is generated by G.

⊓⊔
Another example of a cryptographic scheme based on elliptic curves is the ECIES cryptosystem.

(See Figure 4.2.) It is a hybrid cryptosystem, consisting of using the Diffie-Hellman protocol to derive two keys kE and kM. Then, the key kE is used to encrypt the message using a symmetric encryption scheme Enc, and the key kM is used to authenticate the message using a message authentication code MAC. Both notions will be covered in another chapter. More precisely, the secret key is an integer k ∈ Z∗
n. The public key is a point K = *k.G*. To encrypt m, the sender picks r ∈ Z∗
n, computes R = *r.G* and kE∥kM = KDF(r.K∥extra1), where extra1 includes some extra public information about the message. (This is defined in the standard.) Then, c = EnckE(m)
and d = MACkM (c∥extra2), where extra2 includes some other extra public information about the message requiring to be authenticated. The ciphertext is the triplet (*R, c, d*). To decrypt it, the receiver computes S = *k.R* and kE∥kM = KDF(S∥extra1).

Then, he checks that d =
MACkM (c∥extra2) and computes m = DeckE(c).

The ECDSA algorithm is a digital signature algorithm based on elliptic curves. It will be presented in another chapter.

## 4.8 Pairing-Based Cryptography

For some pairs of elliptic curves G1 and G2 we can construct a function

$e:G_1\times G_2\to G_T$
to a group GT (with multiplicative notations) with the following properties:

- e is easy to compute;

- e is **bilinear**: e(*aP, bQ*) = e(*P, Q*)ab for all *a, b* ∈ Z, P ∈ G1, and Q ∈ G2;
- e is **non-degenerate**: e(*P, Q*) ̸= 1 for some P ∈ G1 and Q ∈ G2.
This construction is made possible when using *supersingular* elliptic curves which have been seen before. However, the choice of this curve is very delicate.

There are several types of pairing.

- Type-1 pairing: we have G1 = G2. This is quite common on supersingular elliptic curves.
This is a common case for cryptography.
- Type-2 pairing. We have G1 ̸= G2 and there exists an efficiently computable (non-degenerate)
homomorphism from G2 to G1.
- Type-3 pairing. We have G1 ̸= G2 and there exists no efficiently computable (non-degenerate)
homomorphism between G1 and G2. This is also a common case for cryptography.
- Type-4 pairing. We have same as Type-2 with efficient hashing into G2. Those pairings are
usually not efficient for cryptography.
With Type-1 pairing, we have G1 = G2. This can have bad consequences on the security of some cryptographic algorithms based on this curve because we can now easily distinguish if a tuple
(*P, A, B, C*) is of form (*P, xP, yP, xyP*) or of form (*P, xP, yP, zP*) with *x, y, z* ∈ Z. (We do so by checking that e(*A, B*) = e(*P, C*).) This is the *decisional Diffie-Hellman problem* (DDH) that we have already met in a previous chapter when we solved it in the group Z∗
p with the help of the Legendre symbol. In such a curve G1 = G2, the decisional Diffie-Hellman problem is easy to solve but we can hope that the *computational Diffie-Hellman problem* remains hard. This is the gap Diffie-Hellman problem. If it is so, the group is called a *gap group*. Cryptographic constructions on those curves should mind this.

Otherwise, the availability of this function e gave birth to new cryptographic constructions:

- Joux 2000 [47]: a 3-party Diffie-Hellman key agreement using only one communication round
(there existed other protocols using more rounds without pairing);
- Boneh-Franklin 2001 [24]: identity-based encryption (this was the first efficient construction); - Boneh-Lynn-Shacham 2003 [25]: a signature scheme with short signatures (the signature is
only one point in an elliptic curve);
- Bonneh-Boyen 2004 [22, 23]: a signature scheme which is secure without using hashing
(namely, without a random oracle);
- Sahai-Water 2004 [72]: attribute-based encryption (in which users have attributes, and allowing to broadcast a ciphertext to a set of users sharing the same attribute).
We only detail the first construction in this chapter. The Boneh-Franklin IBE will be given in Chapter 8. The Boneh-Lynn-Shacham and Boneh-Boyen signatures will be given in Chapter 7.

Let G generate a subgroup of prime order p of G1 = G2 such that e(*G, G*) ̸= 1.

- Alice picks a ∈ Zp and broadcasts A = aG; - Bob picks b ∈ Zp and broadcasts B = bG;
- Charlie picks c ∈ Zp and broadcasts C = cG;
- all compute K = e(G, G)abc:
- Alice computes e(*B, C*)a = K;
- Bob computes e(*C, A*)b = K;
- Charlie computes e(*A, B*)c = K.