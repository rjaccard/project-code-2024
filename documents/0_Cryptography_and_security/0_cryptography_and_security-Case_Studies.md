
## Appendix A Case Studies A.1 Wifi: Wep/Wpa/Wpa2

WEP.

Before 2003, WiFi was secured by WEP, and sometimes by SKA as well. Both use an encryption function in which the ciphertext consists of a nonce IV and the XOR between the plaintext and the keystream generated by RC4, in which K is the concatenation of IV and the secret key. This key is pre-shared. The nonce is pretty small: 3 bytes. So, it eventually repeats. Also, the access point can manage up to 4 keys. So, the keys are eventually shared by many devices.

The SKA (Shared Key Authentication) algorithm was used to authenticate the host to the access point: the access point was sending a challenge and the host had to respond with the encryption of this challenge. Clearly, this leaks to an observer some IV and the keystream generated by this IV.

So, it allows to decrypt communications using the same IV!

Due to this terrible weakness, SKA stopped to be used at all. So, we had no peer authentication.

The WEP (Wired-Equivalent Privacy) protocol consists of encrypting communication.

There is an integrity protection based on a CRC32 algorithm: the message x is concatenated with a CRC32(x) function. But since CRC32 is completely linear, the protection is void [26]: the encryption of x would be

$$y=(x||\mathsf{C R C32}(x))\oplus\mathrm{{hysetminus}}$$
but the encryption of x ⊕ δ would be

$y\oplus(\delta\|\mathsf{CRC32}(\delta))=((x\oplus\delta)\|\mathsf{CRC32}(x\oplus\delta))\oplus\mathsf{keystream}$
So, an adversary willing to substitute x ⊕ δ to x would just substitute y ⊕ δ∥CRC32(δ) to y, which is doable without knowing x or the key: we only need the ciphertext and δ.

There are also obvious weaknesses due to repetition of IV.

In addition to this, there are some key recovery known-plaintext attacks which are really impressive (it only requires 20 000 packets [75]). So, there is almost no security.

WPA.

In 2003, a new system called WPA-TKIP (Temporal Key Integrity Protocol) was introduced to regularly modify the value of K in the RC4 encryption. In addition to this, alternatives to the pre-shared key system were introduced with EAP (Extensible Authentication Protocol). For instance, authentication can be based on a certificate and/or a user/password pair and outsourced to a RADIUS server. WPA2.

The latest version replaces RC4 by AES in CCM mode.

## A.2 Block Chains

Bitcoin is a virtual currency which was released in 2009 by an anonymous person under the pseudonym *Satoshi Nakamoto*. It is based on a completely decentralized structure. There is no central bank. No inflation. No regulation. Anyone can create his own account and identify with an ECDSA public key. All transactions are public.

Transactions generate *unspent transaction outputs* (UTXO). The concept of *transaction* consists, for a user, in signing a message which says that he takes the few UTXO he owns and he spreads them among a list of users (which can include himself). This means that a transaction links to previous transactions (on which we shall collect the UTXO of the signer) and gives a list of shares associated to ECDSA public keys. These shares become the new UTXOs. Of course, the transaction is only valid if the sum of the shares is equal to the sum of the input UTXO and if these are valid UTXO. This raises the problem of identifying whether some value is really unspent.

To check that, we need to check that among all past transactions, none has ever used this amount. This reduces to making sure that every user agrees on what is the list of all past transactions.

For that, transactions are published in a public ledger. Essentially, this is a chain of blocks.

A block consists of the hash of the previous block (except for the genesis block), the list of all transactions since the ones in the last block, and a *proof-of-work*. Miners are collecting transactions and blocks. They consider as valid only the blocks which form the largest chain of blocks. Every period (which is of 10 minutes for bitcoins), they create a new block and broadcast it. There is a reward for the miner which makes a valid block.

The proof of work is such that the SHA256 hash of a block starts with many zeros. As of June
2016, the difficulty is to make them start with 69 zeros.

## A.3 Mobile Telephony

The main security concern in mobile telephony is the authentication of the user. This is critical for the business model. Privacy is a secondary concern. GSM.

In the GSM architecture, users buy devices and subscribe to a home network. After subscription, they get a SIM card to be put inside the device and can connect to arbitrary networks.

The SIM card and the home network share a symmetric key Ki which is critical. It is never given to the device nor to the visited network. This key is used to map a random challenge RAND to a response SRES and to an encryption key KC. When the mobile system connects to a visited network, it identifies itself so that the visited network can ask the home network for some triplets
(RAND, SRES, KC). Then, the network challenges the mobile system by sending the value of RAND.

The SIM card computes SRES and KC and gives the result to the device. The device answers to the network with SRES. If it matches, the device is authenticated, and they can start communicating by encrypting using KC.

Prior to the authentication, the identification is done in clear in the first time when the device connects to the network. Then, the device and network synchronize on some temporary pseudonym which is sent encrypted by the network and used in clear the next time to identify. This is a pretty weak privacy protection.1
The algorithms to compute SRES (called A3) and KC (called A8) from Ki and RAND are only used by the SIM card and the home network. So, they do not need to be standard. Normally, the used algorithms are pretty good, but some weak ones such as COMP128 are circulating and careless operators may use them and deploy a poorly secured network: if a key recovery on A3 is possible, an adversary can send some chosen RAND challenges to the telephone to get the SRES
in return over the air, and do the key recovery. If the key recovery on A8 is possible, a similar attack can be done by the telephone itself. If the key Ki is recovered, the SIM card can be cloned!

The KC-based encryption of the communication is done by all devices and visited networks.

So, it must be standard. There are several options for encryption. (The option is imposed by the network to the device.) They can use A5/0, meaning that they don't use encryption. Otherwise, they can use A5/1, a weaker algorithm A5/2, or a stronger algorithm A5/3. Since fake networks can impose a weak encryption which is susceptible to key recovery attacks and that the key to be used is independent from the algorithm, the entire encryption system is weak.

We note that there is no integrity protection in the communication: the plaintext is just XORed to a keystream. Furthermore, replaying RAND forces to reuse the same keystream. So, message transmission has a weak security. 3G.

In 3G mobile telephony, the challenges are authenticated and cannot be replayed. Furthermore, there is some integrity protection in messages (with a MAC) using another challengedependent symmetric key.

The challenges are protected using the MILENAGE scheme. Essentially, it comes from a secret key and a counter, which is authenticated and encrypted for privacy reasons. More precisely, there is a counter-based Nonce which is authenticated together with a non-repeating random value Rnd by a MAC-function f1 and which is encrypted with a stream cipher f5 using Rnd as a nonce (see, Fig. A.1). The challenge consists of Rnd, the authentication code, and the encrypted nonce. When the card receives the challenge, the nonce is decrypted and authenticated. Then, it is checked that the nonce is correct (e.g., based on the counter). So, the challenge can neither be forged nor reused.

The A3 algorithm is now replaced by an algorithm called f2 while A8 is replaced by two algorithms f3 and f4 to produce an encryption key and an authentication key, respectively. The overall architecture is depicted on Fig. A.2.

Encryption (f8) and MAC (f9) are done based on the KASUMI block cipher, using a special mode of operation.

The main security problem in 3G lies in the fact that networks are not authenticated to the mobile system. So, a fake network could still abuse the device. Furthermore, there is no encryption awareness: if the network (fake or not) imposes no encryption, the user is not aware of it.

## A.4 Signal

Signal is a secure communication protocol which is used for instant messaging (it is used in WhatsApp). It was designed for secure messaging (confidentiality, integrity, and authentication)

and also with the notions of forward secrecy, *future secrecy*, and *plausible deniability* for stronger privacy enforcement.

Forward secrecy means that even though long-term secret may leak in the future, the confidentiality of current communication is preserved. Typically, we use Diffie-Hellman key agreement with ephemeral keys and erase these keys once the key agreement is done, so that they cannot leak. The ephemeral keys are authenticated with the long-term keys. So, leakage of long-term keys does not threaten confidentiality.

Future secrecy means that even though ephemeral secrets may leak, they do not compromise the secrecy of future communications. By doing frequent Diffie-Hellman key agreements, we are ensured that the leakage of ephemeral keys only affects communications within this session.

Plausible deniability means that no evidence will leak from communication.

In particular, nothing is signed with a long-term key.

To achieve forward secrecy, Signal uses the concept of "*ratchet*". A ratchet is a mechanical device which can only move in only one direction. The key derivation of ephemeral keys should also be prevented to be stepped backward to achieve forward secrecy. Signal uses a double ratchet. One ratchet is based on Diffie-Hellman key agreement. For communication between Alice and Bob, every time the direction of communication changes, one Diffie-Hellman key agreement is done to derive a new secret key. In a second ratchet, this secret is updated using a one-way cryptographic function to derive a secret key for every new message, sent in the same direction.

To enforce plausible deniability, we use a triple Diffie-Hellman key agreement on the elliptic curve Curve25519. Essentially, given a long-term secret key a for Alice, a long-term public key bG
for Bob, an ephemeral secret key xa,eph for Alice, and an ephemeral public key xb,ephG for Bob, Alice can compute three secrets axb,ephG, xa,ephbG, and xa,ephxb,ephG. The only one depending on the long-term secret is axb,ephG. It can be computed with an ephemeral secret xb,eph as well, so this is no evidence which is binding for Alice. If we used *abG*, it would be binding as this can only be computed by Alice or Bob.

## A.5 Nfc Creditcard Payment

Credit cards mostly use the EMV payment standard. (EMV stands for Europay, Mastercard, and Visa.) Now, the wireless technology offers payment systems for credit cards. Those equipped with an NFC chip can now be used for contactless payment. Protocols are nearly the same but operate through the radio channel.

Essentially, when a *point of sale* (PoS) requests for payment, it asks the card to pay and the card does it without any action required from the holder on the card, as long as the radio contact with the card was made. First, the PoS gets the certificate for the public key of the card and extra identity information such as the serial number of the card (called PAN). Then, the PoS sends the amount to be paid and a nonce UN. The card then increments a transaction counter ATC and computes what is called a *cryptogram* AC and a signature SDAD. The cryptogram AC is actually a MAC computed on the amount to be paid, ATC, and information about the PoS. The MAC is based on a secret key which is shared with the bank. So, only the bank will understand the cryptogram. The signature SDAD signs AC, UN, the amount to pay, ATC, and information about the PoS. The signature can be verified by the PoS with the public key in the certificate. It can also be used to get the money if there is a problem with AC. Otherwise, only AC and the message authenticated by AC is sent to the bank to collect the payment.

Non-wireless payment with EMV are very similar. There are many variants and options though. Clearly, the wireless technology can let the holder unaware that a payment is happening in his card. The amount paid by the card may be different to the amount he is willing to pay. Normally, the payment terminal is trusted to display the correct amount but this is only an act of faith. Next, the PoS is not authenticated. Finally, the protocol leaks some private information such as the identity of the card and its serial number. This is sent in clear through a radio channel to whoever asks for it to the card in a polite enough way (i.e., by following the standard protocol). Hence, we can easily imagine skimming attacks, in which malicious people would collect credit card numbers. We can also easily mount a relay attack to make people in the street pay in a remote shop.

Relay attacks are real threats to wireless access control system. They are being used to unlock cars and start the engine, to gain access to buildings or hotel rooms, to pay tolls on the highway, to pay with NFC whenever no PIN code is required, to access public transport, etc.

## A.6 Bluetooth

Bluetooth is used to connect many sorts of wireless devices in a short-range network. There are several security modes. The standard one adds security on the link level. In this mode, devices can be *paired* with each other. This requires some input by the user. The default mode of a device is to be connectable but not visible: it does not answer to broadcast messages but only to messages sent to it. So, to be paired, it has to be put temporarily in a visible mode, where the devices can discover each other through the broadcast messages.

Paired devices share a long-term secret key. For each session, they authenticate in a challenge/response protocol using this key and derive session-dependent encryption keys. Again, the encryption is done by a stream cipher (with the synchronized clock to play the role of the nonce).

So, there is no integrity protection for messages.

The legacy *pairing protocol* from the version 2.0 of Bluetooth distinguishes devices on which we can count on some memory and on a keyboard, from other (dummy) devices. On regular devices, the user must type an ephemeral PIN code on both devices. This PIN code is randomly selected by the user but must be the same on both devices. After that, the PIN code is not to be used anymore and can be discarded. Based on the PIN code, the two devices will exchange some nonces and derive the long-term symmetric key called the *link key*. On dummy devices, the PIN code is built in by the manufacturer and the user must type it on the other device. The dummy device does not want to have to store too many link keys (if it is to be paired with many other devices). So, it rather generates a unique *unit key* for himself when it is reset (e.g., switched on for the first time) and uses the pairing protocol to securely send his unit key to the other device. This implies that a third device could get the key controlling the security between the two devices by pairing with the dummy device.

More precisely, regular devices compute an ephemeral key Kinit with an algorithm E22 based on the PIN and a random number. This key is used to encrypt the two nonces in both directions.

Finally, the two nonces are used to derive the long-term key Klink with the algorithm E21 (see Fig. A.3). With a dummy device, there is no exchange of a nonce but the dummy device uses Kinit to encrypt his long-term key Kunit, which is transmitted to the other device.

This pairing protocol is pretty weak when the PIN is short (which is often the case) and the adversary can listen to the communication during the pairing process [46]. If either the PIN is hard to find by exhaustive search or the communication is done in a safe place, the protocol is secure. It could eventually become secure by doing some frequent updates of the link key based on a previous one (which we call *repairing*), because it is unlikely that the adversary will be able to follow the updates in all protocols.

Encryption is done by a stream cipher called E0 which is synchronous in the sense that the nonce which is used is the value of the clock register. So, devices must be synchronized. We note that encryption adds a linear redundancy check (CRC) which was originally aimed to protect the integrity but its security is void, as it was discussed in the case of the WEP security. So, communications can be corrupted.

Version 2.1.

The 2.1 version adds some public-key cryptography techniques for pairing. This is called *Secure Simple Pairing (SSP)* protocol. This protocol distinguishes four association models. The ones offering resistance to active attacks are the *numeric comparison*, in which a human operator must compare two numeric strings which play the role of a Short Authenticated String (SAS), and the *passkey entry*, in which the human user must enter an ephemeral secret (like in the legacy pairing). Two other techniques offer resistance to passive adversaries: *just works*, which is the same as the numeric comparison except that the comparison is not done, and *out-of-band*, which requires another (presumably) secure channel for key transmission.

For all variants, the two devices start with the Elliptic Curve Diffie-Hellman (ECDH) protocol to set up a secret DHKey. Then, they authenticate the ECDH execution in a way which depends on the association model. This phase also determines some nonces NA and NB, and some random values rA and rB. All this is fed to the algorithms f3 and f2 for checking and establishing the link key. The protocol is depicted on Fig. A.4.

In authentication stage 1, the numeric comparison model just consists of authenticating the ECDH exchanges by using the SAS. The protocol is depicted on Fig. A.5. The SAS is a numeric string which is displayed by both devices. The human operator tells both devices if the strings match (in the *numeric comparison* model), or this human comparison is skipped (in the just works model), in which case some active attacks are feasible. In the passkey entry model, the secret and the ECDH public keys are committed in both ways, then opened. This authenticates the ECDH keys. In the out-of-band model, another channel authenticates the commitments, in which the input: PKA, c input: c pick NA ∈U {0, 1}128 pick NB ∈U {0, 1}128 set rA = rB = 0 set rA = rB = 0 cB ←−−−−−−−−−−−− cB ← f1(PKB, c PKA, NB, 0) NA −−−−−−−−−−−−→ ˆcB ?= f1( c PKB, PKA, ˆNB, 0) NB ←−−−−−−−−−−−− VA ← g(PKA, c PKB, NA, ˆNB) VB ← g( c PKA, PKB, ˆNA, NB) display VA display VB check VA = VB output: NA, ˆNB, rA, rB output: ˆNA, NB, rA, rB
secret is set to a random value. Then, the commitments are opened in the regular channel.

In all cases, the idea is that we use ECDH with public keys authenticated in one way or another.

ECDH uses the elliptic curve P192 from p. 43 and a KDF function of the x-coordinate.

The numeric comparison variant is quite interesting to look at more closely. Actually, it is based on a tricky interleave of a commitment cB to NB and the nonce NA selection. (See Fig. A.5.) In this protocol, if the honest device A and B do not see the same public keys PKA and PKB, the adversary cannot make this protocol succeed. Indeed, he would have to make sure that VA = VB for that. But to achieve VA = VB, he must control these values. However, the adversary cannot predict the value of VB before he receives NB from device B (because VB is based on NB which is hidden in the commitment), and the adversary cannot influence the value of VA after he has sent cB to device A (because the commitment makes sure he can opens it only to one NB value, and the adversary does not know NA when he releases cB). So, VA = VB occurs with small probability in that case.

Version 3.0.

The 3.0 version makes Bluetooth compatible with WiFi by using a specific key derivation function to generate a specific link key to be used in this new channel. It is called Bluetooth High Speed (HS), and also AMP for Alternate MAC/PHY channel.

Version 4.0.

The 4.0 version adds some protocol for sensors. It is called Bluetooth Low Energy
(LE). It includes new key derivation and pairing protocols.

## A.7 The Biometric Passport

ICAO, the UN organization standardizing passports, released in 2004 the first version of the MRTD (Machine Readable Travel Document) standard. This mandates that passports feature biometric recognition mechanism based on face recognition (mandatory), fingerprint or iris recognition (optional), with the support of a contactless chip. MRTD can be read by machines in two complementary ways: a Machine Readable Zone (MRZ) can be optically scanned, and they can communicate with the chip.

The MRZ includes basic information such as the name of the person, its date of birth, nationality, gender, the serial number of the passport, and its expiration date. The document number, date of birth, and expiration dates are elements which are used as a kind of password to run a (poor) password-based key exchange protocol and establish a secure channel. This is done by the (optional) *Basic Access Control (BAC)* protocol. Once done, triple DES and a variant of encrypted CBCMAC (EMAC) are used for the secure channel.

Several data groups are stored in the memory of the chip. The mandatory ones are the soft copy of the MRZ and a picture of the face. Another mandatory element contains the hash of all data groups to be authenticated, a signature of the list of digests, and sometimes a certificate for verifying the public key of the signature. This means that countries build their own publickey infrastructure. Passport issuing agencies have a certificate. The root self-signed certificate is authenticated by diplomatic protocols between countries. So, data groups are very securely authenticated. This authentication mechanism is called *passive authentication*. The memory of the chip also has room for many other data groups to contain private information such as fingerprint, iris scan, signature, address, profession, person to notify, electronic visas, travel records, etc.

An optional *Active Authentication (AA)* protocol can be used to prevent cloning attacks. With this protocol, the chip proves that it knows a secret key associated to a public key. The public key is one of the authenticated data groups, and the secret key never leaves the memory of the chip (i.e., it is not readable). This protocol is almost never implemented.

Recent versions of the standard now include an *Extended Access Control (EAC)* protocol. It includes PACE: a stronger protocol than BAC which is a PAKE based on the information from the MRZ. So, it is only vulnerable to a bruteforce online attack and provides forward secrecy. EAC also includes the Chip Authentication protocol which replaces AA. It also includes the Terminal Authentication protocol which authenticates the terminal based on an ECDSA certificate from the visited country. If this country is authorized, the reader can then read the non-mandatory data groups.

Overall, the data authentication of the MRTD technology is very secure (assuming that certificates are really verified, which may not always be the case). The BAC protocol leaks and provides poor security against unauthorized access to the chip but PACE and Terminal Authentication fixes it in EAC. Secure messaging is based on outdated algorithms (triple DES) that are still secure. Finally, the RFID technology which is used leaks private information. The usage of biometric data also leads to many types of threats.

## A.8 Tls

The TLS protocol (for *Transport Layer Security*) secures Internet exchanges: typically, the HTTP protocol. Several protocols are used, mostly the handshake protocol, to set up the cryptographic algorithms and a symmetric key, and the application data protocol which is the secure channel. The TLS communication is stateful. The state includes a session identifier, the peer certificate (if any), the selection of the cryptographic algorithms called cipher suite (if already selected), a master secret and nonces (if set up), and a sequence number to count the packets. The cipher suite includes an algorithm for peer authentication and key exchange, and a cipher spec which identifies a symmetric encryption and authentication algorithm.

In TLS 1.0, the algorithm for authentication and key exchange is mostly RSA (PKCS#1), but Diffie-Hellman with several variants (ephemeral, or semi-ephemeral) can also be used. Other algorithms have been added. If RSA is used, the handshake consists, for the server, in sending his RSA public key certificate. Then, the client selects a pre-master-secret, transfers it using the RSA public key of the server, and both the client and the server derive some secrets from it.

The cipher spec in TLS 1.0 include the NULL algorithm (doing nothing), DES, triple DES, DES with a 40-bit key, IDEA, RC4 (with 40-bit or 128-bit keys), and others, for encryption. Authentication is mostly done by algorithms called MD5 or SHA1. This means that HMAC based on these hash functions is used.

If the stream cipher RC4 is used, there is no nonce but the RC4 engine is never reset. This means that the state of the RC4 generator is kept in the session state for the next message to be encrypted. If a block cipher is used, it is with the CBC mode with a secret IV established during the handshake protocol.

The record protocol (to transmit data) uses the MAC-then-encrypt paradigm. If a block cipher is used, it is actually a MAC-then-pad-then-encrypt construction. A padding is done to obtain a integral sequence of blocks.

Both RC4 and the block ciphers have major security problems, these days. This will be fixed in the 1.3 version of TLS by moving to AES with a more decent authenticated encryption mode of operation.

The current draft of TLS 1.3 also includes changes in the key exchange algorithms. Now, the standard separates key exchange from peer authentication. Key exchange is exclusively done with ephemeral Diffie-Hellman, on an elliptic curve or in a field Zp. So, it provides *forward secrecy*.

Authentication is done either with RSA certificates, or ECDSA certificates, or with the PSK
method. PSK stands for *pre-shared key*. It consists in setting the pre master key to a key which was established in a previous session (this is called a *resumption*). Then, key derivation generates the session symmetric keys using HKDF. The encryption includes AES (in GCM or CCM mode)
and the stream cipher CHACHA20.

As for elliptic curves, TLS 1.3 requires secp256r1 to be implemented and also recommends X25519.