
## Chapter 2 Diffie-Hellman Cryptography

This chapter recalls algebraic notions to introduce the Diffie-Hellman key exchange protocol. For that, basic notions of group theory are recalled, as well as algorithmic methods.

## 2.1 Arithmetics And Zn

A *prime number* is a positive integer having exactly two positive factors: 1 and itself. Integers have a unique factorization, up to permutation, into a product of prime numbers and a unit which is either +1 or −1.

For all a ∈ Z and *n >* 0, there exists a unique way to write a = qn + r with *q, r* ∈ Z and
0 ≤ *r < n*. This is the *Euclidean division*. We call r the *remainder* and we write it r = a mod n.

We stress that there exist two different notations for mod: one (the above one) is a dyadic operation, and the other is an attribute to an equivalence. Indeed, we write a ≡ b (mod n) to denote that b − a is divisible by n, or equivalently, that a mod n = b mod n: somehow, a and b are "equal", but only modulo n.

The modulo operation is the basis of the definition for Zn. We can define it simply by saying that it is the set {0, 1*, . . . , n* − 1} together with new arithmetic operations ⊞ and ⊠. We define

$$a\boxplus b=(a+b)\bmod n\qquad\qquad a\boxtimes b=(a\times b)\bmod n$$
Then, we easily show that they are associative and commutative, that 0 is neutral for ⊞, that 1 is neutral for ⊠, and that every element has an inverse for ⊞, but not necessarily for ⊠. We have distributivity of ⊠ over ⊞ as well.

## 2.2 Some Notions Of Group Theory

Definition 2.1. A group G is a set with a two-input operation + such that

- *the set is* closed under the operation: for all a and b in G, we have a + b ∈ G; - *the operation is* associative: for all a, b, c ∈ G*, we have* a + (b + c) = (a + b) + c; - *there exists a* neutral element 0 (which is necessarily unique): for all a ∈ G, we have
a + 0 = 0 + a = a;
- *every set element has an* inverse: for all a ∈ G, there exists an element in G denoted by −a
such that a + (−a) = (−a) + a = 0.
We say the group is Abelian if the operation is further commutative: for all a and b in G, we have a + b = b + a.

As we have a single operation in groups, there exist essentially two families of notations: the additive and the multiplicative notation. With additive notations (like in the above definition), the operation is denoted by +, ⊕, ⊞ or any similar symbol, the neutral element is denoted 0, O,
..., and the inverse of x is denoted −x. With multiplicative notations, the operation is denoted ×,
⊗, ⊠, ·, the neutral element is 1, I, e, and the inverse of x is 1
x, x−1, ... Due to associativity, we can add (resp. multiply) an element x to itself n times and define *n.x* (resp. xn).

As usual in algebra, mappings from a group to another group which preserve the group operation equalities are called *group homomorphisms*. They are *isomorphisms* if they are further bijective. An isomorphism can be seen as a change of notations as it preserves the algebraic structures. For instance, the addition tables on Fig. 1.1, p. 3, gives to the set G = {A, B*, . . . ,* Z} a group structure which is isomorphic to Z26 by f(A) = 0, f(B) = 1, etc.

We can consider several group constructors:

- we can consider *subgroups* of a bigger group, e.g. the smallest group containing a given
subset of elements, which is then called the subgroup generated by these elements;
- the *product* of two groups, and the group raised to a power n, the group of functions from
a given set to a group;
- the *quotient* of an Abelian group by one of its subgroup.
An important structure theorem about Z says that all its subgroups are of form nZ.

Theorem 2.2. Given a subgroup H of Z other than {0}, we define n as the smallest positive element of H. We have H = nZ.

Proof. Since n ∈ H, it is clear that nZ ⊆ H, since H must be closed by addition and inversion.

To show that H ⊆ nZ, we take a ∈ H arbitrary and we show that a is a multiple of n. For this, we make the Euclidean division of a by n and obtain q and r such that a = qn + r and
0 ≤ *r < n*. Since H is closed and since *a, n* ∈ H, we must have r = a − qn ∈ H. Since n is the smallest positive element of H and 0 ≤ *r < n*, we must have r = 0. So, a = qn: a is a multiple of n.

⊓⊔
Here is a consequence.

Theorem 2.3. Given a (multiplicative) finite group G and g ∈ G*, we define the* order of g as being the smallest positive integer n *such that* gn = 1*. For any integer* i, gi = 1 is equivalent to i being a multiple of n.

Proof. We define H as the set of all integers i such that gi = 1. Clearly, H is closed by addition
(if gi = 1 and gj = 1, then gi+j = gigj = 1) and by inversion (if gi = 1, then g−i = 1/gi = 1).

So, H is a subgroup of Z. Using the previous theorem, we have H = nZ where n is the smallest positive element of H, i.e., the order of g. Consequently, gi = 1 is equivalent to i ∈ H which is equivalent to i ∈ nZ which is equivalent to i being a multiple of n.

⊓⊔
Theorem 2.4. Given a (multiplicative) finite group G and g ∈ G, the subgroup generated by g is
⟨g⟩ = {g0, g1, . . . , gn−1} where n is its cardinality.

Proof. We know that ⟨g⟩ = {. . . , g−2, g−1, 1, g1, g2*, . . .*}.

Clearly, {g0, g1, . . . , gn−1*} ⊆ ⟨*g⟩.

To show the inclusion in the other direction, we let a *∈ ⟨*g⟩ be arbitrary and we want to show that a ∈ {g0, g1*, . . . , g*n−1}. The element a can be written a = gi with i ∈ Z. Let i = qn+r be the Euclidean division of i by n. We have gi = gqn+r = gr with 0 ≤ *r < n*. So, a ∈ {g0, g1*, . . . , g*n−1}.

Thus, ⟨g⟩ = {g0, g1*, . . . , g*n−1}.

To show that the cardinality of ⟨g⟩ is n, we just observe that for 0 ≤ *i, j < n*, gi = gj implies that gi−j = 1, so that i − j is a multiple of n. But since 0 ≤ *i, j < n*, this implies that i = j.

⊓⊔
Actually gi = gj is equivalent to i ≡ j (mod n). Since exponents of g can be taken modulo n, we have indeed an isomorphism between Zn and ⟨g⟩ by mapping i to gi.

The *order* of a finite group is its cardinality. (So, the order of an element is the order of the subgroup that it spans.) The *Lagrange Theorem* says that in a finite group, the order of any element must be a factor of the order of the group. Consequently, in a finite multiplicative group of order n, for every group element g, we have gn = 1.

A simple consequence is that if G has a prime order p, then all its elements except 1 have order p, so they are generators of G.

In 1976, Diffie and Hellman published the foundations of public key cryptography [32]. This paper included a *key exchange protocol*. The Diffie-Hellman key exchange protocol is used so that two people, Alice and Bob, who did not originally share any secret and who are communicating over a public channel, can set up a symmetric secret key. This works in a group generated by some g. Alice first secretly picks a random x computes X = gx and sends X to Bob. Bob does the same. He secretly picks a random y computes Y = gy and sends Y to Alice. Then, Alice computes K = Y x which should match the result that Bob gets by computing K = Xy. This would be K = gxy. Interestingly, for some groups, there exists no efficient algorithm to compute K from X and Y although there is an algorithm to compute gx from g and x. This is why we have this key exchange protocol.

## 2.3 Algorithms For Big Numbers

Output: b = e · a
The algorithms that children learn at school to add and multiply "big" decimal numbers can generalize in any other basis (e.g., binary, hexadecimal). The addition algorithm has a linear complexity in terms of the length of the operands. The multiplication algorithm has a quadratic complexity.

The multiplication algorithm is in fact not a *group multiplication* algorithm: it is the multiplication of a (big) integer by an element of a (additive) group. We can actually use the same algorithm to raise an element of a (multiplicative) group to some integral power. More generally, it works on any *monoid* instead of a group: we do not need every element to have an inverse.

Given a monoid (using additive notations), if we want to multiply a monoid element a by an integer e, we can decompose e in binary and scan the bits of e while doubling and adding terms.

This is called the *double-and-add algorithm*. We have different algorithms based on the scanning direction: there are the right-to-left and the left-to-right algorithms. The algorithm scanning e from right to left is as follows:
Input: a ∈ G and an integer e of ℓ bits written as e = Pℓ−1
i=0 ei2i with ei ∈ {0, 1}

1: x ← 0
2: y ← a
3: for i = 0 to ℓ − 1 do
4:
        if ei = 1 then

5:
            x ← x + y

6:
        end if

7:
        y ← y + y

Output: b = e · a

 8: end for
 9: b ← x
By scanning from left to right, we obtain the following algorithm:
Input: a ∈ G and an integer e of ℓ bits written as e = Pℓ−1
                                                                            i=0 ei2i with ei ∈ {0, 1}

1: x ← 0
2: for i = ℓ − 1 to 0 do

3:
        x ← x + x

4:
        if ei = 1 then

5:
x ← x + a
6:
end if
7: end for
8: b ← x If instead we use a monoid with multiplicative notations, we can just replace the + by × in the previous algorithms and obtain the *square-and-multiply* algorithms. Assuming that a monoid multiplication has a complexity O(T), raising an element to the power e has a complexity O(T log e).

This is much lower than T × e.

## 2.4 Zn**: The Ring Of Residues Modulo** N

Definition 2.5. A ring is a set with two two-input operations: + and ×. It must be such that

- the set together with + is an Abelian group, - the set is closed under multiplication,
- × is associative, - there is a neutral element 1 for ×, - × is distributed over +.
The ring is commutative if × is further commutative.

Not every element in a ring has a multiplicative inverse. Those which have one are called *units*.

Given a ring R, R∗ denotes the set of units. It forms a group with × and is often called the multiplicative group of R.

As for groups, there are several ring constructors: subrings, ring products, ring powers, quotient. Actually, the notion of subring is not so useful. We favor the notion of *ideal* of a ring, which is a subgroup for + that is stable by multiplication by any ring element (instead of just being stable by any subring element). For instance, nZ is an ideal of Z as it is a subgroup and the product of any nZ element by any Z element is still in nZ. We can quotient rings by ideals. We have already defined Zn in an ad-hoc way. The cerebral way consist of making a quotient of the ring Z by its ideal nZ. So, Zn is actually a ring when considering the addition and multiplication reduced modulo n. The group of units of Zn is Z∗
n. It is a multiplicative group. The order of Z∗
n is denoted by φ(n).

For n large, of size ℓ bits, we thus have

- an algorithm of complexity O(ℓ) to compute additions in Zn; - an algorithm of complexity O(ℓ2) to compute multiplications in Zn;
- an algorithm of complexity O(ℓ2 log e) to raise to the power e in Zn.
We can also compute inverses modulo n, with complexity O(ℓ2). Actually, the following algorithm computes (as the result u) the inverse of a modulo b, when it has an inverse: Input: a and b, two integers of at most ℓ bits Output: d, *u, v* such that d = au + bv = gcd(*a, b*)
Complexity: O(ℓ2)

1: ⃗x ← (a, 1, 0), ⃗y ← (b, 0, 1)
2: while y1 > 0 do
3:
make an Euclidean division x1 = qy1 + r
4:
do simultaneously ⃗x ← ⃗y and ⃗y ← ⃗x − q⃗y
5: end while
6: (d, u, v) ← ⃗x
The vectors x and y have three coordinates, where x1 and y1 denote their first coordinate, respectively. If we consider the algorithm computing only the first coordinate, we recognize the Euclid algorithm which computes gcd(*a, b*). It will thus be the result in d at the end of the algorithm.

We can easily see that all vectors are of form (*α, β, γ*) such that α = aβ + bγ. Consequently, the result is such that d = au + bv. The algorithm is called the *extended Euclid algorithm*.

Theorem 2.6. A number a is invertible modulo a number b *if and only if* gcd(*a, b*) = 1.

Proof. If a is invertible modulo b, then ax − qb is always divisible by gcd(*a, b*). We take x a being the inverse of a and q be the integral quotient of ax by b so that ax − qb = 1. We obtain that 1 is divisible by gcd(*a, b*). Hence, gcd(*a, b*) = 1.

Conversely, if gcd(*a, b*), the extended Euclid algorithm produces u and v such that 1 = au+bv.

Consequently, (au) mod b = 1, thus a is invertible. Therefore, gcd(*a, b*) = 1 is equivalent to a being invertible modulo b.

⊓⊔

## 2.5 Orders In A Group

Definition 2.7. Given x in a (multiplicative) group G*, the* order of an element x ∈ G is the smallest positive integer m *such that* xm = 1.

We have seen (see Th. 2.2) that every subgroup of Z can be written in the form nZ, where n is the smallest non-negative element of the subgroup. So, the set of integers i such that xi = 1 forms a subgroup of Z. If we write it as mZ as in the above result, where m is the smallest positive element of this subgroup, we call m *the order of* x in G.

Definition 2.8. Given a (multiplicative) group G*, the* exponent of G is the smallest positive integer λ *such that* xλ = 1 for all x ∈ G.

Indeed, the set of integers i such that xi = 1 for all x ∈ G forms also a subgroup of Z. We further know that it contains the order of G, due to the Lagrange Theorem. If we write it as λZ
as in the above result, λ is *the exponent of* G. We note that λ must be part of the previously defined subgroup for any x, so λ must be a multiple of the order m of x. This is true for all x.

Furthermore, due to the Lagrange Theorem, we deduce that the order of G must be a multiple of λ, which is itself a multiple of m.

When G = Z∗
n, we write λ = λ(n) where λ defines *the Carmichael function*. We obtain that for all x ∈ Z∗
n, φ(n) is a multiple of λ(n), which is itself a multiple of the order of every x in Z∗
n.

We will see that the general formula to compute φ is given by

$\varphi(p_{1}^{a_{1}}\times\cdots\times p_{r}^{a_{r}})=(p_{1}-1)p_{1}^{a_{1}-1}\times\cdots\times(p_{r}-1)p_{r}^{a_{r}-1}$
when the pi's are pairwise different prime numbers and the ai's are positive integers.

There is a general formula to compute λ(n) similar to the one of φ(n):

$$\lambda(p_{1}^{a_{1}}\times\cdots\times p_{r}^{a_{r}})=\mbox{lcm}\left(\lambda(p_{1}^{a_{1}}),\ldots,\lambda(p_{r}^{a_{r}})\right)$$

where the $p_{i}$'s are pairwise different prime numbers and the $a_{i}$'s are positive integers. For $p$ prime and $\alpha$ integer, we have

$$\lambda(p^{\alpha})=\left\{\begin{array}{ll}\varphi(p^{\alpha})&\mbox{if}\;\;p>2\;\mbox{or}\;\;\alpha\leq2\\ \frac{1}{2}\varphi(p^{\alpha})&\mbox{if}\;\;p=2\;\mbox{and}\;\;\alpha\geq3\end{array}\right.$$
Checking a generator in groups with known order.

In a group G whose order n is known, it is not so easy to check whether an element g ∈ G is a generator. When the factorization of n into primes n = pa1
1 × · · · × par r is known, we can efficiently do it by checking, for all i, that gn/pi ̸= 1. This is indeed a necessary condition (otherwise, the order would be smaller). Since the order of n must be a factor of n, we can see that, if not equal to n, it must be a factor of some n/pi. So, the conditions together are sufficient for g to be a generator. We obtain the following algorithm:
Input: an element g in an Abelian cyclic group of order with known factorization n = pa1
1 ×· · ·×par r
1: **for** i = 1 to r do
2:
y ← gn/pi
3:
if y = 1 then
4:
output "g is not a generator" and stop
5:
end if
6: end for 7: output "g is a generator"
If g is provided by some untrusted party, g could have been maliciously selected and there is essentially no better way to check that g is a generator. So, it is required to know the factorization of n.

When g can be trusted to have been randomly selected, it is unlikely that gn/pi = 1 for any large pi. So, it is enough to check the condition for every small pi. Since it is easy to find the small prime factors of n, this is doable by knowing only n. To go back to the untrusted g case, a way to convince that g was randomly selected could be to provide the seed of the pseudorandom generator which generated g.

In more details, we consider the following algorithm:
Input: an element g in an Abelian cyclic group of known order n, a parameter B

1: find the list p1, . . . , ps of all prime factors of n which are less than B
2: for i = 1 to s do
3:
        y ← gn/pi

4:
        if y = 1 then 5:
            output "g is not a generator" and stop 6:
        end if

 7: end for
 8: output "g may be a generator"
Clearly, if the output is "g is not a generator", the statement is correct. Then, we show that when
g is uniformly selected in the group, the probability that g is not a generator given that the output
is "g may be a generator" is bounded by
                                                         log n

                              B log B . With a relatively small B, we can find the list
p1, . . . , ps easily and we can thus have a good confidence that the output is correct.
  We define the event Ei that g

pi xj mod paj
           j
              = 0

                                n
                                pi = 1 when g is uniformly distributed in G. To prove correctness,
we first think of G with another representation.
                                                    We already know that G is cyclic, so it is
isomorphic to Zn. If we take n = pa1
                                   1 × · · · × par
                                               r
                                                  the complete factorization into primes pi with
pi ̸= pj and ai ≥ 1, by using the Chinese Remainder Theorem (to be seen later), we obtain that
G is isomorphic to Zpa1
                     1 × · · · × Zpar
                                  r . So, picking g uniformly in G is equivalent to picking some
independent xj uniformly in Zp
                              aj
                              j
                                 for j = 1, . . . , r. So, Ei is equivalent to having n

for j = 1, . . . , r. Since paj
                          j
                             divides
                                       n
                                      pi for all j ̸= i, this is always the case. But for j = i, this is
equivalent pai−1
             i
                 xi mod pai
                           i
                              = 0. This is equivalent to xi mod pi = 0. So, the probability of Ei is
equal to
          1
         pi . We further note that the events Ei are independent.
   Let Maybe be the event that the output is "g may be a generator". The event Maybe is the
complement of E1 ∪ · · · ∪ Es. The event NotGenerator that g is not a generator is E1 ∪ · · · ∪ Et.
So,

$$\Pr[\mathsf{NotGenerator}|\mathsf{Maybe}]=\Pr[E_{s+1}\cup\cdots\cup E_{r}|\neg(E_{1}\cup\cdots\cup E_{s})]\leq\sum_{i=s+1}^{r}\Pr[E_{i}|\neg(E_{1}\cup\cdots\cup E_{s})]$$
B . So,

Since $E_{i}$ and $E_{1}\cup\cdots\cup E_{s}$ are independent, for $i>s$ we have $\Pr[E_{i}|\neg(E_{1}\cup\cdots\cup E_{s})]=\Pr[E_{i}]=\frac{1}{p_{i}}\leq\frac{1}{B}$. So,

$$\Pr[\mathsf{NotGenerator}|\mathsf{Maybe}]\leq\frac{r-s}{B}\leq\frac{\log n}{B\log B}$$
where the last inequality comes from n ≥ pas+1
s+1 · · · par r ≥ ps+1 *· · ·* pr ≥ Br−s.

As another application, we can *find* a generator of G by picking g at random and checking that gn/pi ̸= 1 for every small prime factor pi of n. The algorithm is as follows:
Input: the order n of an Abelian cyclic group and a parameter B

1: find the list p1*, . . . , p*s of all prime factors of n which are less than B
2: repeat
3:
pick a random g in the group
4:
b ← true
5:
for i = 1 to s do
6:
y ← gn/pi
7:
if y = 1 then
8:
b ← false
9:
end if
10:
end for
11: **until** b 12: output g
The probability that the output is not a generator is bounded by
log n
B log B .

This algorithm can be used to find a generator of Z∗
p when p is prime with n = p − 1.

## 2.6 The Zp Field

Definition 2.9. A field is a ring in which every non-zero element has a multiplicative inverse.

Whenever p is a prime number, Zp is a field. Indeed, every non-zero element must have its gcd with p equal to 1, so it must be invertible. So, Z∗
p = {1*, . . . , p* − 1}. It has order p − 1. Due to the Lagrange Theorem, we deduce that for all x ∈ Z∗
p, we have xp−1 mod p = 1. This is called the Little Fermat Theorem.

Theorem 2.10 (Little Fermat Theorem). If p is a prime number, for all integer x coprime with p*, we have* xp−1 mod p = 1.

We could further show that Z∗
p is cyclic. I.e., it has a generator, as a multiplicative group.

Theorem 2.11. If p is a prime number, Z∗
p is a cyclic group.

Given a group G of order n and an element g generating G, the *discrete logarithm problem* is specified by a group element y. It consists of finding an integer x such that gx = y.

More precisely, we define this computational problem in terms of a *game*. This game depends on some security parameter λ (for instance, the bitlength of the group order) and is specified by a sequence of steps. It starts by settting up some parameters (here: the group we are interested in) then by initializing the game (here: by chosing the instance X the logarithm of which must be found). Then, an *adversary* is given the instance and what he has access to and must return something.

Finally, there is a winning condition (here: that the returned value is a discrete logarithm of X).

DL(λ):

1: Setup(1λ) → (group*, q, g*) 2: pick x ∈ Zq 3: X ← gx 4: A(group, q, g, X) → x′
5: **return** 1X=gx′
The *advantage* of the game is often simply defined as the probability to win. (Sometimes, we subtract the probability of a trivial winning probability.)
We say that the discrete logarithm problem is hard with respect to Setup if, for every probabilistic polynomial-time algorithm A, the advantage is a negligible function of the security parameter λ.

The notion of "negligible" function is asymptotic. We say that f(λ) is negligible when λ → +∞
if for every positive integer n, we have f(λ) = O(λ−n).

In some groups, this problem is easy. For instance, in the group Zn (for which we have to translate the above definition, since Zn has some additive notation), it is easy to find x such that
(gx) mod n = y. We just have to divide y by g modulo n.

In any group of order bounded by B, the Baby-Step Giant-Step algorithm [76] solves the discrete logarithm problem in O(
√
B) group operations.

In the group Z∗
p, the discrete logarithm problem is believed to be hard.

The discrete logarithm problem is easy to solve if we can do computations on a quantum computer (this is the Shor algorithm [78]). It is also easy if the group order n has only small prime factors (this is the Pohlig-Hellman algorithm [63]). For Z∗
p, the best known algorithm is GNFS [56, 65] and runs with a pretty large complexity

$e^{\left(\sqrt[3]{\frac{64}{9}+o(1)}\right)\left(\ln n\right)^{\frac{1}{3}}\left(\ln\ln n\right)^{\frac{2}{3}}}$

. 
We should however be careful with what this figure suggests for security. Indeed, this algorithm spends most of its time to precompute the tables which only depend on the selection of the group and the generator. As many such parameters are very popular (as coming from standard), it is realistic to believe that some agencies may have spent some time to run this precomputation. After the precomputation is done, the attack itself works with a lower complexity of

$e^{\left(\sqrt[3]{3+o(1)}\right)\left(\ln n\right)^{\frac{1}{3}}\left(\ln\ln n\right)^{\frac{2}{3}}}$

... 
The difference can be quite large as reported by Adrian et al. [11] in this table:

| p      |  length          | precomputation   | attack   |
|--------|------------------|------------------|----------|
| (bits) | (core-time)      | (core-time)      |          |
| 512    | 10               | .                | 2 years  |
| 768    | 36 500 years     | 2 days           |          |
| 1 024  | 45 000 000 years | 30 days          |          |

(This was computed by extrapolating some experimental values.) So, after spending a year of precomputation with 28 500 cores, computing a discrete logarithm in Z∗
p with a given prime p of
768 bits will only take 2 days. This was used to mount the Logjam attack on TLS [11] in 2015.

For instance, SSH2 uses p = 21024 − 2960 − 1 + 264⌊2894π + 129093⌋, g = 2, and q = p−1
2 .

(Both p and q are prime, and g has order q in Zp.) So, if one can invest 45 million core.years of computation, any discrete logarithm for SSH2 could be computed in one core.month.

## 2.7 The Diffie-Hellman Key Exchange, Concretely

In the specified Diffie-Hellman key exchange protocol [32], there are a few problems to be avoided:

- the existence of subgroups, in general, creates security problems and should be avoided, by
taking groups of prime order;
- the existence of the trivial subgroup {1} cannot be avoided and a specific countermeasure
must be taken in the protocol;
- the representation of the value K = gxy may have some bad distribution and it cannot be
used directly as a symmetric key.
For this, we use a group whose order is a prime number q. The numbers x and y shall be selected in Z∗
q with a uniform distribution. This way, X and Y are uniformly distributed in the group without 1. Alice resp. Bob must verify that Y resp. X is different from 1, i.e. that they are not in the subgroup {1}. Finally, gxy goes through a specific algorithm called a Key Derivation Function (KDF) to generate a useable key K. 

The protocol may resist to *passive attacks*, where the adversary only sees the messages X and Y but does not modify them. The security holds if the Computational Diffie-Hellman problem (CDH) is hard. Given a group, a generator g, and its order, this problem is specified by a pair
(*X, Y* ) of group elements. The goal is to compute gxy where x and y are such that X = gx and Y = gy. Like for the discrete logarithm problem, this one may be easy or hard to solve depending on the group. Typically, we would select a subgroup of Z∗
p of prime order q, or an elliptic curve
(to be seen in a future chapter). The corresponding game is as follows:
CDH(λ):
1: Setup(1λ) → (group*, q, g*)
2: pick x, y ∈ Zq
3: X ← gx, Y ← gy
4: A(group, q, g, X, Y ) → K
5: **return** 1K=gxy Another important problem is the *Decisional Diffie-Hellman problem* (DDH) in which the adversary must recognize if a proposed solution to the computational problem is correct or not. More precisely, the game is as follows:
DDH(*λ, b*):
1: Setup(1λ) → (group*, q, g*)
2: pick x, y, z ∈ Zq 3: if b = 1 **then** z ← xy
4: X ← gx, Y ← gy, Z ← gz
5: A(group, q, g, X, Y, Z) → t
6: **return** t The advantage is no longer the probability to return 1. It is the difference between b = 1 and b = 0 which is an additional parameter in the game:

$$\operatorname{Adv}_{\mathcal{A}}(\lambda)=\operatorname*{Pr}[\mathsf{DDH}(\lambda,1)\to1]-\operatorname*{Pr}[\mathsf{DDH}(\lambda,0)\to1]$$
Note that the hardness of the computational Diffie-Hellman problem implies the hardness of the discrete logarithm problem in the same group. Indeed, if we could solve the discrete logarithm problem, we would compute x from X = gx, then Y x.

One example of concrete implementation of the Diffie-Hellman problem is given by RFC 2631 [68].

There, the KDF function is a specific algorithm based on the SHA1 hash function (to be seen in a future chapter). The result is used to encrypt a key which is used in further exchanges. This is called *key wrapping*.

In RFC 2631, setting up the group means to define two prime numbers p and q and one integer g such that ⟨g⟩ is a subgroup of order q in Z∗
p. One method to check that (*p, q, g*) is a valid triplet of parameters consists of checking that p and q are prime, that g mod p ̸= 1, and that gq mod p = 1. Indeed, in such case, it is guaranteed that g has order q in Z∗
p. Later, to check that X and Y are in the subgroup generated by g, we just have to check that Xq mod p = 1 and Y q mod p = 1, respectively. This is due to the following result which essentially says that there is a unique subgroup of Z∗
p of order q. So, numbers g, X, and Y of order q are necessarily in the same subgroup ⟨g⟩.

Theorem 2.12. If p and q *are prime numbers and if* g mod p ̸= 1, gq mod p = 1, then ⟨g⟩ is the set of all x ∈ Zp *such that* xq mod p = 1. It is a subgroup of Z∗
p of order q.

Proof. Due to the assumptions, g is clearly an element of Z∗
p of order q and q divides p − 1.

The point that ⟨g*⟩ ⊆ {*x ∈ Zp; xq mod p = 1} is trivial: since gq mod p = 1, x = gu is such that xq mod p = 1.

To show the converse, we take x ∈ Zp such that xq mod p = 1. We want to show that x is in ⟨g⟩. Clearly, xq−1 is the inverse of x in Z∗
p, so x ∈ Z∗
p. We use the fact that Z∗
p is cyclic and take a generator θ of this group. Since it is a generator, we can write g = θa and x = θb. Due to gq mod p = 1, we have aq mod (p − 1) = 0. Similarly, bq mod (p − 1) = 0. We can thus write a = a′ p−1
q and b = b′ p−1
q for some integers a′ and b′. Since g mod p ̸= 1, we have 1 ≤ a′ < q. So, a′ is invertible modulo q (remember that q is prime). Let c be the inverse of a′ modulo q. We have

$$g^{b^{\prime}c}\equiv\theta^{a b^{\prime}c}\equiv\theta^{a^{\prime}b c}\equiv x^{a^{\prime}c}{\pmod{p}}$$
Since we can write a′c = 1 + kq for some integer k, we deduce that gb′c ≡ x (mod p). So, x *∈ ⟨*g⟩.

⊓⊔
The plain Diffie-Hellman protocol does not authenticate the ephemeral public keys. Hence, a man-in-the-middle can replace them by others and run separate protocols with both participants. This is an *active attack* which is not avoided by this protocol. However, if the participant succeed to communicate directly without the man-in-the-middle interfering, they may realize that they did not obtain the same key. A more devastating active attack is one which make the participants receive the same key, which the adversary can compute as well. This is possible when there are small subgroups. Hence, we should avoid using groups which have small subgroup. The standard method is to use groups of prime order.

## 2.8 The Elgamal Public-Key Cryptosystem

In a *Public-Key Cryptosystem (PKC)*, we have three algorithms:

- a *key generation algorithm*, which is a pseudorandom generator producing a key pair (pk, sk),
pk being publicly revealed while sk being private;
- an *encryption algorithm*, which could be a randomized algorithm producing a ciphertext
given a plaintext and a public key pk;
- a *decryption algorithm*, being deterministic, and reconstructing the plaintext from the ciphertext and the private key sk.
When the encryption is probabilistic, the ciphertext is often larger than the plaintext, and encrypting the same plaintext several times produces different ciphertexts. We only require that the decryption reconstructs the correct plaintext.

One way to transform the Diffie-Hellman key exchange protocol [32] into a PKC consists of treating Bob's key y as a long-term private key and Y = gy as his public key. Then, Alice would generate x, compute X = gx, and encrypt her message by using a symmetric encryption scheme based on the key K = KDF(Y x). The ciphertext would consists of X and the encrypted message.

Bob would recover the message by doing the symmetric decryption with the key K = KDF(Xy).

This type of construction is typical for what we call *hybrid encryption*. We combine public-key cryptography, which is used to derive a symmetric key K (the Diffie-Hellman protocol, in our case), with symmetric encryption. The ElGamal cryptosystem follows this idea but uses no KDF
and takes one-time-pad (over the group) as a symmetric encryption.

In the *ElGamal public-key cryptosystem* [37], there is a common group ⟨g⟩ of order n. To generate a key pair, we pick sk = x ∈ Zn and compute pk = y = gx. A message must be a group element m *∈ ⟨*g⟩. To encrypt m, we pick r ∈ Zn, compute u = gr, v = myr, and the ciphertext is (*u, v*). (See Fig. 2.1.) To decrypt (*u, v*), we compute m = vu−x. Clearly, this construction is correct as vu−x = myrg−rx = mgrxg−rx = m Once the domain parameters are selected (i.e., the group itself), and since it can be common to all users, the key generation is pretty simple: an exponential computation in the group. Encryption and decryption have a similar cost.

Fig. 2.1 shall be understood as follows: the domain parameters g and n are common and assumed to be reliably known to all participants. There is an initial secure transmission of the public key y from the receiver to the sender. The security of this transmission must preserve the authenticity and integrity of y but not necessarily the confidentiality. The ciphertext is transmitted through an insecure communication channel.

The security of the ElGamal cryptosystem comprises two different problems: the decryption problem and the key recovery problem. Clearly, key recovery is equivalent to the discrete logarithm problem. We show below that the decryption problem is equivalent to the computational Diffie- Hellman problem. So, we need the computational Diffie-Hellman problem to be hard to have security.

There are other tricky things to say about the security of the ElGamal cryptosystem, but this will be left for another course.

To show that the ElGamal decryption problem is equivalent to the computational Diffie-
Hellman problem, we use the notion of *Turing reduction* which can compare two problems. If we have an oracle (which is used like a subroutine in a program) to solve the computational Diffie-Hellman problem, then we can make an algorithm which will solve the ElGamal decryption problem and vice versa. Let assume that G is fixed and that the oracle takes X and Y as input and gives K as output, with X = gx, Y = gy, K = gxy. Then, given a public key y and a ciphertext
(*u, v*), we can set X = u and Y = y, query the oracle, and compute *v/K*. We can easy see that when (*u, v*) is the encryption of m, i.e. that u = gr and v = myr, then *v/K* is actually m. So, this solved the ElGamal decryption problem given the Diffie-Hellman oracle. For the contrary, we assume a decryption oracle such that given y and (*u, v*) the oracle returns the decryption of (*u, v*)
with the secret key associated to y. Given X and Y , we can set u = X, y = Y , and set a random v in the group. After querying the oracle we obtain m and we can easily see that K = *v/m* is the answer to the computational Diffie-Hellman problem. This way, we show the equivalence between the two problems.